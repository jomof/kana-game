/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { LitElement, html, css } from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import * as wanakana from 'wanakana';
import { markTokens, anyMarked, selectBestGroup, isCompleted, parseEnglishString, } from './kana-control-logic.js';
// Re-export for consumers
export { makeQuestion } from './kana-control-logic.js';
const DEFAULT_INITIAL_SCORE = 100;
const DEFAULT_CORRECT_GUESS_FACTOR = 0.95;
const DEFAULT_INCORRECT_GUESS_FACTOR = 0.7;
/**
 * A Japanese kana input control component with optional question/progress display.
 * Converts romaji input to kana using WanaKana IME mode.
 *
 * @fires question-complete - Fired when the question is completed successfully. Detail is `{ finalSkeleton: string, wrongAttempts: number, correctAttempts: string[], englishHints: string[], score: number }`.
 * @fires question-skipped - Fired when the question is skipped. Detail is `{ finalSkeleton: string, wrongAttempts: number, correctAttempts: string[], englishHints: string[], score: number }`.
 * @fires request-next-question - Fired when the user requests the next question (by clicking the button or pressing Enter after completion).
 * @slot - This element has a slot
 * @csspart action-button - The complete/skip button inside the input
 * @csspart kana-input - The kana input field
 * @csspart english - The English prompt/question display
 * @csspart skeleton - The progress skeleton display
 * @csspart debug - The debug output container
 */
let KanaControl = class KanaControl extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * The current question being displayed/answered.
         */
        this.question = null;
        /**
         * Parsed English parts with furigana annotations.
         */
        this.parsedEnglish = [];
        /**
         * Visibility state for each furigana annotation.
         */
        this._furiganaVisibility = [];
        /**
         * Number of wrong attempts for the current question.
         */
        this._wrongAttempts = 0;
        /**
         * List of correct attempts for the current question.
         */
        this._correctAttempts = [];
        /**
         * Set of indices of English words for which the hint was revealed.
         */
        this._revealedHintIndices = new Set();
        /**
         * Whether the full answer has been revealed (after user gave up).
         * When true, the skeleton displays the full answer with missed parts highlighted.
         */
        this._revealedAnswer = false;
        /**
         * The answer text for which grammar detail is currently expanded.
         * null if no grammar detail is shown.
         */
        this._expandedGrammarAnswer = null;
        /**
         * Debug mode - shows all possible remaining sentences.
         */
        this.debug = false;
        /**
         * Initial score for a question. Defaults to 100.
         */
        this.initialScore = DEFAULT_INITIAL_SCORE;
        /**
         * Factor to multiply score by when a correct guess is made.
         * Defaults to 0.95.
         */
        this.correctGuessFactor = DEFAULT_CORRECT_GUESS_FACTOR;
        /**
         * Factor to multiply score by when an incorrect guess is made.
         * Defaults to 0.7.
         */
        this.incorrectGuessFactor = DEFAULT_INCORRECT_GUESS_FACTOR;
        /**
         * Current score for the active question.
         * -1 indicates the question has not been started or score is hidden.
         * The score is updated based on user guesses:
         * - Correct guess: score * correctGuessFactor (unless completed)
         * - Incorrect guess: score * incorrectGuessFactor
         * - Reveal answer: score * (incorrectGuessFactor ^ missing_tokens)
         */
        this.score = -1;
    }
    static { this.styles = css `
    :host {
      display: block;
      position: relative;
      border: solid 1px gray;
      padding: 16px;
      max-width: 800px;
      /* Allow both light & dark; rely on page color scheme */
    }

    #score {
      position: absolute;
      top: 10px;
      right: 10px;
      font-family: 'Noto Sans JP', sans-serif;
      font-size: 20px;
      font-weight: bold;
      color: #666;
    }

    input#kana-input {
      box-sizing: border-box;
      width: 100%;
      padding-left: 2.5em;
      padding-right: 2.5em;
      border-radius: 8px;

      font-family: 'Noto Sans JP', sans-serif;
      font-size: 22px;
      line-height: 33px;
      text-align: center;
    }

    .input-wrapper {
      position: relative;
      width: 100%;
    }

    #action-button {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      cursor: pointer;
      font-size: 24px;
      padding: 0;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      transition: background-color 0.2s;
      z-index: 1;
    }

    #action-button:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    #action-button.complete {
      color: #4caf50;
    }

    #action-button.skip {
      color: #999;
    }

    #action-button.hint {
      color: #ff9800;
    }

    #english {
      font-family: 'Noto Sans JP', sans-serif;
      font-size: 30px;
      text-align: center;
      width: 100%;
      margin-bottom: 10px;
    }

    .english-word[has-furigana] {
      cursor: pointer;
    }

    #skeleton {
      font-family: 'Noto Sans JP', sans-serif;
      font-size: 22px;
      text-align: center;
      width: 100%;
      margin-bottom: 10px;
    }

      #skeleton .skeleton {
        display: flex;
        justify-content: center;
        align-items: baseline;
        gap: 0.2em;
        flex-wrap: wrap;
        line-height: 2;
      }

      #skeleton .token {
        font-weight: normal;
        color: #999;
      }

      #skeleton .token.marked {
        font-weight: bold;
        color: #000;
      }

      #skeleton .token.missed {
        font-weight: bold;
        color: #f57f17;
      }

      #skeleton .completed {
        color: #4caf50;
        font-size: 1.5em;
        margin-left: 0.3em;
      }

      #possible-answers {
        margin-top: 20px;
        text-align: center;
        font-family: 'Noto Sans JP', sans-serif;
      }

      .possible-answer {
        margin-bottom: 8px;
        font-size: 18px;
        color: #666;
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        transition: background-color 0.2s;
      }

      .possible-answer:hover {
        background-color: rgba(0, 0, 0, 0.05);
      }

      .grammar-badges {
        display: flex;
        justify-content: center;
        gap: 4px;
        margin-top: 4px;
        flex-wrap: wrap;
      }

      .grammar-badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 10px;
        color: white;
        text-transform: uppercase;
        font-weight: 500;
        letter-spacing: 0.5px;
      }

      .grammar-badge.formality-formal { background: #2196f3; }
      .grammar-badge.formality-neutral { background: #9e9e9e; }
      .grammar-badge.formality-casual { background: #ff9800; }

      .grammar-badge.gender-masculine { background: #3f51b5; }
      .grammar-badge.gender-feminine { background: #e91e63; }

      .grammar-badge.register { background: #673ab7; }

      .grammar-detail {
        margin-top: 8px;
        padding: 12px;
        background: #f5f5f5;
        border-radius: 8px;
        font-size: 14px;
        text-align: left;
      }

      .grammar-detail-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
      }

      .grammar-detail-label {
        font-weight: 500;
        color: #666;
      }

      .grammar-detail-value {
        color: #333;
      }

      /* Dark mode adjustments */
      @media (prefers-color-scheme: dark) {
        :host {
          background-color: #121212;
          border-color: #444;
        }
        #score {
          color: #aaa;
        }
        #skeleton .token.marked {
          color: #eee;
        }
        #skeleton .token.missed {
          color: #ffeb3b;
        }
        #skeleton .token {
          color: #888;
        }
        span#english, #english {
          color: #eee;
        }
        .possible-answer {
          color: #aaa;
        }
        .possible-answer:hover {
          background-color: rgba(255, 255, 255, 0.05);
        }
        .grammar-detail {
          background: #2a2a2a;
        }
        .grammar-detail-label {
          color: #aaa;
        }
        .grammar-detail-value {
          color: #ddd;
        }
      }
  `; }
    /**
     * Supply a new question to display.
     * Resets all state related to the previous question (attempts, hints, revealed answer).
     *
     * @param question - The question to display
     *
     * @example
     * ```ts
     * const control = document.querySelector('kana-control');
     * const q = await makeQuestion('I live[すむ] in Seattle[シアトル].', [
     *   '私 は シアトル に 住んでいます。',
     * ]);
     * control.supplyQuestion(q);
     * ```
     */
    async supplyQuestion(question) {
        this.question = structuredClone(question);
        this.parsedEnglish = parseEnglishString(question.english);
        this._furiganaVisibility = new Array(this.parsedEnglish.length).fill(false);
        this._wrongAttempts = 0;
        this._correctAttempts = [];
        this._revealedHintIndices.clear();
        this._revealedAnswer = false;
        this._expandedGrammarAnswer = null;
        this.score = -1;
        // Clear input when new question is supplied
        const input = this.renderRoot.querySelector('#kana-input');
        if (input) {
            input.value = '';
        }
        this.requestUpdate();
    }
    render() {
        const groups = this.question ? this.question.parsed : [];
        const best = groups.length > 0 ? selectBestGroup(groups) : [];
        const completed = groups.length > 0 ? isCompleted(best) : false;
        const hasProgress = best.some(t => t.marked);
        let buttonClass = 'skip';
        let buttonText = '⏭';
        let buttonTitle = 'Skip Question';
        if (completed) {
            buttonClass = 'complete';
            buttonText = '➜';
            buttonTitle = 'Next Question';
        }
        else if (this._revealedAnswer) {
            buttonClass = 'skip';
            buttonText = '⏭';
            buttonTitle = 'Next Question';
        }
        else if (hasProgress) {
            buttonClass = 'hint';
            buttonText = '?';
            buttonTitle = 'Reveal Answer';
        }
        return html `
      ${this.score !== -1 ? html `<div id="score">${this.score}</div>` : null}
      ${this.parsedEnglish.length > 0
            ? html `
            <div id="english" part="english">
              ${this.parsedEnglish.map((part, index) => html `
                  <span
                    class="english-word"
                    ?has-furigana=${part.furigana !== ''}
                    @click=${() => this._handleEnglishWordClick(index)}
                  >
                    ${this._furiganaVisibility[index] && part.furigana
                ? html `<ruby
                          ><rb>${part.englishWord}</rb
                          ><rt>${part.furigana}</rt></ruby
                        >`
                : part.englishWord}
                  </span>
                `)}
            </div>
          `
            : html `<div id="english" part="english" style="color: #999;">
            Loading question...
          </div>`}
      ${this.question
            ? html `<div id="skeleton" part="skeleton">${this._renderSkeleton()}</div>`
            : null}
      <div class="input-wrapper">
        <input
          id="kana-input"
          part="kana-input"
          type="text"
          autocapitalize="none"
          autocomplete="off"
          spellcheck="false"
          placeholder="日本語"
          ?disabled=${this._revealedAnswer}
          @keydown=${this._handleKeydown}
        />
        <button
          id="action-button"
          part="action-button"
          class="${buttonClass}"
          @click=${this._handleActionButtonClick}
          title="${buttonTitle}"
        >
          ${buttonText}
        </button>
      </div>
      ${completed || this._revealedAnswer ? this._renderPossibleAnswers() : null}
      ${this.debug && this.question
            ? html `<div id="debug-output" part="debug" style="margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 4px; font-family: monospace; font-size: 14px;">
            ${this._renderDebugInfo()}
          </div>`
            : null}
    `;
    }
    firstUpdated() {
        const input = this.renderRoot.querySelector('#kana-input');
        if (input) {
            // Bind WanaKana IME to convert romaji to kana as user types
            wanakana.bind(input, { IMEMode: true });
        }
    }
    _handleKeydown(e) {
        if (!this.question || e.key !== 'Enter' || this._revealedAnswer)
            return;
        const groups = this.question.parsed;
        // If the question is already completed, pressing Enter requests the next question
        const currentBest = selectBestGroup(groups);
        if (isCompleted(currentBest)) {
            this.dispatchEvent(new CustomEvent('question-complete', {
                bubbles: true,
                composed: true,
                detail: this._getEventDetail()
            }));
            this.dispatchEvent(new CustomEvent('request-next-question', {
                bubbles: true,
                composed: true
            }));
            return;
        }
        const input = e.target;
        const value = input.value;
        // Convert input to hiragana for matching (readings are stored as hiragana)
        const hiragana = wanakana.toHiragana(value);
        const marked = markTokens(groups, hiragana);
        if (anyMarked(marked)) {
            this._correctAttempts = [...this._correctAttempts, value];
            const best = selectBestGroup(groups);
            const completed = isCompleted(best);
            if (completed) {
                // If completed, score is not reduced.
                // If this was the first attempt (score is -1), set to initial score.
                // This handles the "one-shot" case where the user answers correctly in one go.
                if (this.score === -1) {
                    this.score = this.initialScore;
                }
            }
            else {
                // Update score for correct but incomplete guess.
                // Score is multiplied by correctGuessFactor (e.g. 0.95).
                let currentScore = this.score === -1 ? this.initialScore : this.score;
                currentScore = Math.round(currentScore * this.correctGuessFactor);
                this.score = currentScore;
            }
            input.value = '';
            if (completed) {
                // Trigger re-render to update skeleton
                this.requestUpdate();
            }
        }
        else {
            this._wrongAttempts++;
            // Update score for incorrect guess.
            // Score is multiplied by incorrectGuessFactor (e.g. 0.7).
            let currentScore = this.score === -1 ? this.initialScore : this.score;
            currentScore = Math.round(currentScore * this.incorrectGuessFactor);
            this.score = currentScore;
        }
        // Always trigger re-render to update skeleton
        this.requestUpdate();
    }
    _handleActionButtonClick() {
        if (!this.question)
            return;
        const groups = this.question.parsed;
        const best = selectBestGroup(groups);
        const completed = isCompleted(best);
        const hasProgress = best.some(t => t.marked);
        if (completed) {
            this.dispatchEvent(new CustomEvent('question-complete', {
                bubbles: true,
                composed: true,
                detail: this._getEventDetail()
            }));
            this.dispatchEvent(new CustomEvent('request-next-question', {
                bubbles: true,
                composed: true
            }));
        }
        else if (this._revealedAnswer) {
            // User is skipping after revealing answer
            this.dispatchEvent(new CustomEvent('question-skipped', {
                bubbles: true,
                composed: true,
                detail: this._getEventDetail()
            }));
            this.dispatchEvent(new CustomEvent('request-next-question', {
                bubbles: true,
                composed: true
            }));
        }
        else if (hasProgress) {
            // User has progress, reveal answer
            // Calculate score penalty for revealing answer.
            // The penalty is applied for each missing token (excluding punctuation).
            // For each missing token, the score is multiplied by incorrectGuessFactor (e.g. 0.7).
            const missingTokens = best.filter(t => !t.marked && t.pos !== '記号').length;
            let currentScore = this.score === -1 ? this.initialScore : this.score;
            for (let i = 0; i < missingTokens; i++) {
                currentScore = Math.round(currentScore * this.incorrectGuessFactor);
            }
            this.score = currentScore;
            this._revealedAnswer = true;
            this.requestUpdate();
        }
        else {
            // No progress, just skip
            this.dispatchEvent(new CustomEvent('question-skipped', {
                bubbles: true,
                composed: true,
                detail: this._getEventDetail()
            }));
            this.dispatchEvent(new CustomEvent('request-next-question', {
                bubbles: true,
                composed: true
            }));
        }
    }
    _getEventDetail() {
        if (!this.question)
            return {};
        const groups = this.question.parsed;
        const best = selectBestGroup(groups);
        const finalSkeleton = best.map(t => {
            if (t.pos === '記号')
                return t.surface_form;
            return t.marked ? t.surface_form : '_'.repeat(t.surface_form.length);
        }).join('');
        const englishHints = Array.from(this._revealedHintIndices)
            .sort((a, b) => a - b)
            .map(i => this.parsedEnglish[i].englishWord);
        return {
            finalSkeleton,
            wrongAttempts: this._wrongAttempts,
            correctAttempts: [...this._correctAttempts],
            englishHints,
            score: this.score
        };
    }
    _handleEnglishWordClick(index) {
        if (this.parsedEnglish &&
            this.parsedEnglish[index] &&
            this.parsedEnglish[index].furigana) {
            if (index < this._furiganaVisibility.length) {
                const willBeVisible = !this._furiganaVisibility[index];
                this._furiganaVisibility[index] = willBeVisible;
                if (willBeVisible) {
                    this._revealedHintIndices.add(index);
                }
            }
        }
        this.requestUpdate();
    }
    _renderSkeleton() {
        if (!this.question) {
            return html `<div>Loading question...</div>`;
        }
        const groups = this.question.parsed;
        const best = selectBestGroup(groups);
        const completed = isCompleted(best);
        const bestString = best.map(t => t.surface_form).join('');
        const grammar = this.question.answerGrammar?.[bestString];
        return html `
      <div class="skeleton">
        ${best.map((t) => {
            if (t.pos === '記号') {
                return html `${t.surface_form}`;
            }
            if (this._revealedAnswer) {
                // In revealed state, show everything.
                // If it was marked, show normally. If not, show as missed (yellow).
                const isMissed = !t.marked;
                const className = isMissed ? 'token missed' : 'token marked';
                if (isMissed && t.reading) {
                    const hiragana = wanakana.toHiragana(t.reading);
                    const surfaceHiragana = wanakana.toHiragana(t.surface_form);
                    if (hiragana !== surfaceHiragana) {
                        return html `<span class="${className}"
                    ><ruby>${t.surface_form}<rt>${hiragana}</rt></ruby></span
                  >`;
                    }
                }
                return html `<span class="${className}"
                  >${t.surface_form}</span
                >`;
            }
            // Normal state
            return html `<span class="token ${t.marked ? 'marked' : ''}"
                  >${t.marked
                ? t.surface_form
                : '_'.repeat(t.surface_form.length)}</span
                >`;
        })}
        ${completed ? html `<span class="completed">✓</span>` : ''}
      </div>
      ${(completed || this._revealedAnswer) && grammar ? this._renderGrammarBadges(grammar) : null}
    `;
    }
    _renderPossibleAnswers() {
        if (!this.question)
            return null;
        const groups = this.question.parsed;
        const best = selectBestGroup(groups);
        const bestString = best.map(t => t.surface_form).join('');
        // Filter out the answer the user just completed
        const otherGroups = groups.filter(g => g.map(t => t.surface_form).join('') !== bestString);
        if (otherGroups.length === 0)
            return null;
        return html `
      <div id="possible-answers">
        <div style="font-size: 14px; color: #888; margin-bottom: 8px;">Other possible answers:</div>
        ${otherGroups.map(group => {
            const answerText = group.map(t => t.surface_form).join('');
            const grammar = this.question?.answerGrammar?.[answerText];
            const isExpanded = this._expandedGrammarAnswer === answerText;
            return html `
            <div class="possible-answer" @click=${() => this._toggleGrammarDetail(answerText)}>
              <div>
                ${group.map(t => {
                if (t.pos === '記号') {
                    return html `${t.surface_form}`;
                }
                if (t.reading) {
                    const hiragana = wanakana.toHiragana(t.reading);
                    const surfaceHiragana = wanakana.toHiragana(t.surface_form);
                    if (hiragana !== surfaceHiragana) {
                        return html `<ruby>${t.surface_form}<rt>${hiragana}</rt></ruby>`;
                    }
                }
                return html `${t.surface_form}`;
            })}
              </div>
              ${grammar ? this._renderGrammarBadges(grammar) : null}
              ${grammar && isExpanded ? this._renderGrammarDetail(grammar) : null}
            </div>
          `;
        })}
      </div>
    `;
    }
    _toggleGrammarDetail(answerText) {
        if (this._expandedGrammarAnswer === answerText) {
            this._expandedGrammarAnswer = null;
        }
        else {
            this._expandedGrammarAnswer = answerText;
        }
        this.requestUpdate();
    }
    _renderGrammarBadges(grammar) {
        const badges = [];
        // Formality badge
        badges.push(html `
      <span class="grammar-badge formality-${grammar.formality}">
        ${grammar.formality}
      </span>
    `);
        // Gender badge (only if not neutral)
        if (grammar.gender !== 'neutral') {
            badges.push(html `
        <span class="grammar-badge gender-${grammar.gender}">
          ${grammar.gender}
        </span>
      `);
        }
        // Register badges (only non-neutral)
        for (const register of grammar.registers) {
            if (register !== 'neutral') {
                badges.push(html `
          <span class="grammar-badge register">${register}</span>
        `);
            }
        }
        return html `<div class="grammar-badges">${badges}</div>`;
    }
    _renderGrammarDetail(grammar) {
        return html `
      <div class="grammar-detail">
        <div class="grammar-detail-row">
          <span class="grammar-detail-label">Formality:</span>
          <span class="grammar-detail-value">${grammar.formality} (${grammar.formality_score.toFixed(3)})</span>
        </div>
        <div class="grammar-detail-row">
          <span class="grammar-detail-label">Gender:</span>
          <span class="grammar-detail-value">${grammar.gender} (${grammar.gender_score.toFixed(3)})</span>
        </div>
        <div class="grammar-detail-row">
          <span class="grammar-detail-label">Registers:</span>
          <span class="grammar-detail-value">${grammar.registers.join(', ') || 'none'}</span>
        </div>
        <div class="grammar-detail-row">
          <span class="grammar-detail-label">Grammaticality:</span>
          <span class="grammar-detail-value">${grammar.is_grammatic ? '✓' : '✗'} (${(grammar.grammaticality_score * 100).toFixed(1)}%)</span>
        </div>
      </div>
    `;
    }
    _renderDebugInfo() {
        if (!this.question) {
            return html `<div>No question loaded</div>`;
        }
        const groups = this.question.parsed;
        // Filter to only show groups that could still be completed
        // (groups where all marked tokens are still valid)
        const validGroups = groups.filter(group => {
            // If any token is marked, the group is still potentially valid
            const hasMarked = group.some(t => t.marked);
            // If no tokens are marked yet, all groups are valid
            const noMarksYet = !group.some(t => t.marked);
            return hasMarked || noMarksYet;
        });
        return html `
      <div style="margin-bottom: 5px; font-weight: bold; color: #666;">
        Debug: ${validGroups.length} possible sentence${validGroups.length !== 1 ? 's' : ''}
      </div>
      ${validGroups.map((group, idx) => html `
          <div style="padding: 2px 0; color: #333;">
            ${idx + 1}. ${group.map(t => t.surface_form).join('')}
          </div>
        `)}
    `;
    }
};
__decorate([
    state()
], KanaControl.prototype, "question", void 0);
__decorate([
    state()
], KanaControl.prototype, "parsedEnglish", void 0);
__decorate([
    state()
], KanaControl.prototype, "_furiganaVisibility", void 0);
__decorate([
    state()
], KanaControl.prototype, "_wrongAttempts", void 0);
__decorate([
    state()
], KanaControl.prototype, "_correctAttempts", void 0);
__decorate([
    state()
], KanaControl.prototype, "_revealedAnswer", void 0);
__decorate([
    state()
], KanaControl.prototype, "_expandedGrammarAnswer", void 0);
__decorate([
    property({ type: Boolean })
], KanaControl.prototype, "debug", void 0);
__decorate([
    property({ type: Number })
], KanaControl.prototype, "initialScore", void 0);
__decorate([
    property({ type: Number })
], KanaControl.prototype, "correctGuessFactor", void 0);
__decorate([
    property({ type: Number })
], KanaControl.prototype, "incorrectGuessFactor", void 0);
__decorate([
    state()
], KanaControl.prototype, "score", void 0);
KanaControl = __decorate([
    customElement('kana-control')
], KanaControl);
export { KanaControl };
//# sourceMappingURL=kana-control.js.map